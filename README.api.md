# G-PCC (tmc3) C++ API 利用の経緯と課題

## 目的

このドキュメントは、MPEG-PCCの参照実装である `tmc3` を、コマンドライン実行ファイルとしてではなく、C++のライブラリとして利用しようと試みた際の経緯と、そこで判明した課題をまとめたものです。
最終的な目標は、`--config`オプションで指定するような複雑な圧縮設定を、C++のAPIコールを通じて実現することでした。

## 実施経緯

### 1. ライブラリとしてのビルド

当初、このプロジェクトは `tmc3` という単一の実行可能ファイルをビルドする構成になっていました。APIとして利用するため、`mpeg-pcc-tmc13/CMakeLists.txt` に以下の変更を加えました。

-   `tmc3` のソースコード（`mpeg-pcc-tmc13/tmc3` 内）を、`tmc3_lib` という名前の静的ライブラリとしてコンパイルするように変更。
-   APIの利用例を示すための新しい実行可能ファイル `sample_api` を定義。
-   `sample_api` が `tmc3_lib` にリンクし、必要なヘッダファイルをインクルードできるように `target_link_libraries` と `target_include_directories` を設定。

これにより、`tmc3` の機能を外部のプログラムから呼び出すための基本的なビルド環境が整いました。

### 2. `sample_api.cpp` の実装と試行錯誤

次に、APIの主要なエントリーポイントである `pcc::PCCTMC3Encoder3` と `pcc::PCCTMC3Decoder3` を使用して、点群のエンコードとデコードを行う `sample_api.cpp` を実装しました。この過程で、数多くの問題に直面しました。

-   **APIの誤解**: `PayloadBuffer` が `std::vector<char>` を継承していることや、`ply::write` の引数の順序など、ヘッダファイルだけからは読み取りにくい仕様で、多くのコンパイルエラーが発生しました。
-   **パラメータ設定の壁**: コンパイルが通るようになっても、エンコードは成功するものの、デコード後の点群が空になる、あるいはデコーダがクラッシュする（ハングアップ、セグメンテーションフォールト、アサーション失敗）という問題が続きました。

これらの問題の根本原因は、エンコーダに渡す `pcc::EncoderParams` 構造体の設定が極めて複雑であることでした。

## C++ API 利用の難しさ

`tmc3` コマンドラインツールが `--config` ファイルから設定を読み込む際、単に値を構造体にマップしているのではありません。内部では、主に `TMC3.cpp` 内の `ParseParameters`, `sanitizeEncoderOpts`, `deriveParameterSets`, `fixupParameterSets` といった関数群が、以下の処理を行っています。

1.  **パラメータの導出**: ひとつの設定値から、複数の内部パラメータを計算・導出します。
2.  **整合性の検証と修正**: 複数のパラメータ間の矛盾をチェックし、一方を修正したり、無効化したりします。例えば、`predgeom_enabled_flag` と `trisoup_enabled_flag` は同時に有効にできず、自動的にどちらかが無効になります。
3.  **依存関係の解決**: あるフラグが立っているかどうかに応じて、他の多数のパラメータのデフォルト値や挙動が変化します。

つまり、**コマンドラインツールは、高レベルな設定から低レベルなパラメータ群を生成するための、巨大で複雑な「パラメータ導出エンジン」として機能しています。**

一方で、`PCCTMC3Encoder3::compress` のようなC++ APIは、このエンジンによって完全に準備された、矛盾のないパラメータ構造体 (`pcc::EncoderParams`) が渡されることを前提としています。API自体には、高レベルな設定（例：「予測ジオメトリを有効にする」）から、それに必要な全ての低レベルパラメータを自動設定する機能は備わっていません。

これが、APIの利用を困難にしている最大の理由です。設定ファイルを忠実に再現するには、コマンドラインツールのパラメータ導出ロジックの大部分を、APIを呼び出す側のアプリケーションに自前で実装する必要があるのです。

## 結論

今回の試みで作成した `sample_api.cpp` は、G-PCCをライブラリとしてビルドし、基本的なAPI（`compress`, `decompress`）を呼び出すためのサンプルコードとしては有用です。

しかし、`octree-predlift` のような高度な圧縮モードを有効にするためには、このサンプルで試みたような個別のパラメータ設定だけでは不十分です。`TMC3.cpp`のパラメータ導出ロジックを詳細に分析し、それを呼び出し側で再現するという、大規模な追加実装が不可欠となります。

したがって、G-PCC APIは、何か新しいツールに圧縮・伸張機能を「組み込む」ためのものではありますが、その設定は非常に低レベルであり、利用にはMPEG-PCCの符号化仕様に関する深い知識が要求される、というのが現状の結論です。 