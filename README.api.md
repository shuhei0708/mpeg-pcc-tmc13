# `tmc3` をライブラリとして利用し、API経由で呼び出す方法

## 1. 概要

このドキュメントは、MPEG-G PCC (G-PCC) の参照ソフトウェアである `tmc3` を、標準のコマンドラインツールとしてではなく、C++ライブラリとして利用するための手順をまとめたものです。

ここで行った変更により、`tmc3` の主要な機能をカプセル化した静的ライブラリ `libtmc3_lib.a` が生成され、他のC++アプリケーションから直接その機能を呼び出すことが可能になります。

変更のデモンストレーションとして、このライブラリにリンクする簡単なサンプルアプリケーション `sample_api` を追加しました。

## 2. ビルドシステムの変更点

`tmc3` の機能を外部から再利用可能にするため、既存のCMakeビルドシステムに以下の変更を加えました。

### `mpeg-pcc-tmc13/tmc3/CMakeLists.txt`

-   **静的ライブラリの作成**: `main` 関数を含む `TMC3.cpp` を除いたすべてのソースファイルから、`tmc3_lib` という名前の静的ライブラリを生成するように変更しました (`add_library(tmc3_lib STATIC ...)`).
-   **`tmc3` 実行可能ファイルの再定義**: 元の `tmc3` 実行可能ファイルは、`TMC3.cpp` のみを含むようにし、新しく作成した `tmc3_lib` にリンクするようにしました。これにより、コマンドラインツールとしての機能は維持されます。
-   **インクルードディレクトリの公開**: `target_include_directories` を `PUBLIC` および `PRIVATE` スコープで設定し、`tmc3_lib` にリンクするターゲット（`sample_api`など）が、ビルドに必要なヘッダーファイルを自動的に解決できるようにしました。

### `mpeg-pcc-tmc13/CMakeLists.txt`

-   **`sample_api` ターゲットの追加**: 新しい実行可能ファイルターゲット `sample_api` を追加しました (`add_executable(sample_api sample_api.cpp)`).
-   **ライブラリのリンク**: `sample_api` が `tmc3_lib` をリンクするように設定しました (`target_link_libraries(sample_api PRIVATE tmc3_lib)`).

## 3. `sample_api` のビルド手順

以下のコマンドを実行することで、`tmc3` と `sample_api` を含むプロジェクト全体をビルドできます。

```bash
# 1. ビルドディレクトリを作成し、そこに移動します
mkdir build
cd build

# 2. CMakeを実行してビルドファイルを生成します
cmake ..

# 3. makeコマンドでビルドを実行します
make -j
```

ビルドが成功すると、`build/` ディレクトリに `sample_api` という実行可能ファイルが、`build/tmc3/` ディレクトリに `tmc3` という実行可能ファイルがそれぞれ生成されます。

## 4. `sample_api.cpp` について

`sample_api.cpp` は、`tmc3_lib` のAPIを呼び出す基本的な骨格を示すためのサンプルプログラムです。

-   **目的**: APIの呼び出し方の構文を示し、カスタムアプリケーションに統合するための出発点を提供します。
-   **機能**: コマンドラインから入力のPLYファイルを読み込みます。
-   **制限事項**: ファイルの読み込み後は、エンコード・デコード処理のロジックは実装されておらず、プレースホルダーとなっています。これは、`tmc3` のAPIが単純なインメモリ処理を想定して設計されておらず、パラメータ設定やビットストリームのハンドリングが複雑なためです。

実際に意味のある圧縮・解凍処理を実装するには、`tmc3/TMC3.cpp` 内の `SequenceEncoder` および `SequenceDecoder` クラスの実装を詳細に分析し、パラメータの設定や `PayloadBuffer` のシーケンスを正しく模倣する必要があります。 